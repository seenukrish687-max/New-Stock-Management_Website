import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';

// Constants for layout
const MARGIN = 15;
const PAGE_WIDTH = 210; // A4 width in mm
const PRIMARY_COLOR = [37, 99, 235]; // #2563EB (Blue)
const SECONDARY_COLOR = [31, 41, 55]; // #1F2937 (Dark Gray)
const TEXT_COLOR = [31, 41, 55]; // #1F2937
const LIGHT_BG = [241, 245, 249]; // #F1F5F9 (Light Gray)

// Helper to add header
const addHeader = (doc, title, date) => {
    // Company Name
    doc.setFontSize(22);
    doc.setTextColor(...PRIMARY_COLOR);
    doc.setFont('helvetica', 'bold');
    doc.text("Ammachee Stock Management", MARGIN, 20);

    // Date
    doc.setFontSize(14); // Larger font
    doc.setTextColor(...TEXT_COLOR);
    doc.setFont('helvetica', 'bold'); // Bold
    doc.text(date, PAGE_WIDTH - MARGIN, 20, { align: 'right' });

    // Report Title
    doc.setFontSize(16);
    doc.setTextColor(...SECONDARY_COLOR);
    doc.setFont('helvetica', 'bold');
    doc.text(title, MARGIN, 30);

    // Divider Line
    doc.setDrawColor(200);
    doc.line(MARGIN, 35, PAGE_WIDTH - MARGIN, 35);

    return 45; // Return Y position for next content
};

// Helper to add footer
const addFooter = (doc) => {
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(150);
        doc.text("Generated by Daily Stock System", MARGIN, 285);
        doc.text(`Page ${i} of ${pageCount}`, PAGE_WIDTH - MARGIN, 285, { align: 'right' });
    }
};

// Helper to add section title
const addSectionTitle = (doc, title, y) => {
    doc.setFontSize(14);
    doc.setTextColor(...PRIMARY_COLOR);
    doc.setFont('helvetica', 'bold');
    doc.text(title, MARGIN, y);
    return y + 8;
};

export const generateDailyReportPDF = (data, date, filterType, platformFilter = 'All Platforms', intelligentNotes = {}, products = []) => {
    const doc = new jsPDF();
    let y = addHeader(doc, "Daily Stock Report", date);

    // 1. Total Summary
    y = addSectionTitle(doc, "1. Total Summary", y);

    const summaryItems = [
        { label: "Total Sale", value: `${data.totalSales.toFixed(0)} units` }, // Using quantity as units based on request "X units"
        { label: "Total Stock-In", value: `${data.totalStockIn} units` },
        { label: "Total Returns", value: `${data.totalReturns} units` }
    ];

    const boxWidth = (PAGE_WIDTH - (MARGIN * 2)) / 3;
    const boxHeight = 20;

    summaryItems.forEach((item, index) => {
        const x = MARGIN + (index * boxWidth);
        doc.setFillColor(...LIGHT_BG);
        doc.rect(x, y, boxWidth - 2, boxHeight, 'F');

        doc.setFontSize(10);
        doc.setTextColor(...SECONDARY_COLOR);
        doc.setFont('helvetica', 'normal');
        doc.text(item.label, x + 5, y + 8);

        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.text(item.value, x + 5, y + 16);
    });

    y += boxHeight + 10;

    // 2. Sales Breakdown
    if (data.stockOut.length > 0) {
        y = addSectionTitle(doc, "2. Sales Breakdown", y);

        const salesBody = data.stockOut.map(t => [
            t.productName,
            t.quantity,
            `RM ${t.sellingPriceAtTime ? t.sellingPriceAtTime.toFixed(2) : '0.00'}`,
            t.platform || '-',
            t.receiverName || '-',
            `RM ${(t.quantity * (t.sellingPriceAtTime || 0)).toFixed(2)}`
        ]);

        autoTable(doc, {
            startY: y,
            head: [['Product Name', 'Quantity Sold', 'Price', 'Platform', 'Receiver Name', 'Total Amount']],
            body: salesBody,
            theme: 'grid',
            headStyles: { fillColor: PRIMARY_COLOR, textColor: [255, 255, 255] },
            styles: { fontSize: 9, cellPadding: 3 },
            columnStyles: {
                0: { cellWidth: 50 },
                5: { halign: 'right' }
            }
        });
        y = doc.lastAutoTable.finalY + 10;
    }

    // 3. Stock-In Breakdown
    const stockInOnly = data.stockIn.filter(t => t.type === 'IN');
    if (stockInOnly.length > 0) {
        y = addSectionTitle(doc, "3. Stock-In Breakdown", y);

        const stockInBody = stockInOnly.map(t => [
            t.productName,
            t.quantity,
            t.supplier || '-',
            t.date
        ]);

        autoTable(doc, {
            startY: y,
            head: [['Product Name', 'Stock-In Qty', 'Supplier', 'Date']],
            body: stockInBody,
            theme: 'grid',
            headStyles: { fillColor: PRIMARY_COLOR, textColor: [255, 255, 255] },
            styles: { fontSize: 9, cellPadding: 3 }
        });
        y = doc.lastAutoTable.finalY + 10;
    }

    // 4. Return Breakdown
    const returnsOnly = data.stockIn.filter(t => t.type === 'RETURN');
    if (returnsOnly.length > 0) {
        y = addSectionTitle(doc, "4. Return Breakdown", y);

        const returnBody = returnsOnly.map(t => [
            t.productName,
            t.quantity,
            t.platform || '-',
            t.returnReason || '-',
            t.notes || '-'
        ]);

        autoTable(doc, {
            startY: y,
            head: [['Product Name', 'Return Qty', 'Platform', 'Return Reason', 'Notes']],
            body: returnBody,
            theme: 'grid',
            headStyles: { fillColor: PRIMARY_COLOR, textColor: [255, 255, 255] },
            styles: { fontSize: 9, cellPadding: 3 }
        });
        y = doc.lastAutoTable.finalY + 10;
    }

    // 5. Intelligent Notes
    // Check if we need a new page
    if (y > 200) {
        doc.addPage();
        y = 20;
    }

    y = addSectionTitle(doc, "5. Intelligent Notes", y);

    const notesData = [
        [`Top-selling platform: ${intelligentNotes.topPlatform || '-'}`],
        [`Platform with lowest sales: ${intelligentNotes.lowestPlatform || '-'}`],
        [`Products with highest return rate: ${intelligentNotes.highestReturnProduct || '-'}`],
        [`Recommended actions: ${intelligentNotes.recommendation || '-'}`]
    ];

    autoTable(doc, {
        startY: y,
        body: notesData,
        theme: 'plain',
        styles: { fontSize: 10, cellPadding: 2 },
        columnStyles: { 0: { fontStyle: 'italic' } }
    });

    y = doc.lastAutoTable.finalY + 10;

    // 6. Remaining Stock Breakdown
    // Check if we need a new page
    if (y > 200) {
        doc.addPage();
        y = 20;
    }

    y = addSectionTitle(doc, "6. Remaining Stock Breakdown", y);

    if (products && products.length > 0) {
        const stockBody = products.map(p => [
            p.name,
            p.category,
            `${p.currentStock} units`
        ]).sort((a, b) => a[0].localeCompare(b[0])); // Sort by product name

        autoTable(doc, {
            startY: y,
            head: [['Product Name', 'Category', 'Available Stock']],
            body: stockBody,
            theme: 'grid',
            headStyles: { fillColor: SECONDARY_COLOR, textColor: [255, 255, 255] },
            styles: { fontSize: 9, cellPadding: 3 },
            columnStyles: {
                2: { halign: 'right', fontStyle: 'bold' }
            }
        });
    } else {
        doc.setFontSize(10);
        doc.setTextColor(...TEXT_COLOR);
        doc.setFont('helvetica', 'italic');
        doc.text("No product data available.", MARGIN, y + 5);
    }

    addFooter(doc);
    doc.save(`Daily_Report_${date}.pdf`);
};

export const generateMonthlyReportPDF = (data, month, platformFilter = 'All Platforms', products = []) => {
    const doc = new jsPDF();

    // --- Header ---
    const [year, monthNum] = month.split('-');
    const dateObj = new Date(year, monthNum - 1);
    const monthName = dateObj.toLocaleString('default', { month: 'long' });
    const formattedDate = `${monthName} ${year}`;

    let y = addHeader(doc, "Monthly Stock Report", formattedDate);

    // 1. Monthly Summary
    y = addSectionTitle(doc, "1. Monthly Summary", y);

    const summaryItems = [
        { label: "Total Sales", value: `${data.totalUnitsSold} units` },
        { label: "Total Sales Value", value: `RM ${data.totalRevenue.toFixed(2)}` },
        { label: "Total Stock-In", value: `${data.totalStockIn} units` },
        { label: "Total Returns", value: `${data.totalReturns} units` },
        { label: "Top Platform", value: data.monthlyInsights?.highestGrowthPlatform || '-' },
        { label: "Most Returned", value: data.monthlyInsights?.unusualReturns?.split(',')[0] || '-' }
    ];

    const boxWidth = (PAGE_WIDTH - (MARGIN * 2)) / 3;
    const boxHeight = 20;

    summaryItems.forEach((item, index) => {
        const row = Math.floor(index / 3);
        const col = index % 3;
        const x = MARGIN + (col * boxWidth);
        const currentY = y + (row * (boxHeight + 5));

        doc.setFillColor(...LIGHT_BG);
        doc.rect(x, currentY, boxWidth - 2, boxHeight, 'F');

        doc.setFontSize(9);
        doc.setTextColor(...SECONDARY_COLOR);
        doc.setFont('helvetica', 'normal');
        doc.text(item.label, x + 5, currentY + 7);

        doc.setFontSize(11);
        doc.setFont('helvetica', 'bold');
        const valueText = doc.splitTextToSize(item.value, boxWidth - 10);
        doc.text(valueText, x + 5, currentY + 15);
    });

    y += (Math.ceil(summaryItems.length / 3) * (boxHeight + 5)) + 10;

    // 2. Sales Breakdown (Separate Table per Platform)
    y = addSectionTitle(doc, "2. Sales Breakdown", y);

    // Group sales by Platform
    const salesByPlatform = {};
    data.stockOut.forEach(t => {
        const platform = t.platform || 'Unknown';
        if (!salesByPlatform[platform]) salesByPlatform[platform] = [];
        salesByPlatform[platform].push(t);
    });

    Object.entries(salesByPlatform).forEach(([platform, transactions]) => {
        // Check page break
        if (y > 220) { doc.addPage(); y = 20; }

        // Platform Sub-header
        doc.setFontSize(11);
        doc.setTextColor(...SECONDARY_COLOR);
        doc.setFont('helvetica', 'bold');
        doc.text(`Platform: ${platform}`, MARGIN, y);
        y += 6;

        // Aggregate by Product within this Platform
        const productMap = {};
        transactions.forEach(t => {
            if (!productMap[t.productName]) {
                productMap[t.productName] = {
                    productName: t.productName,
                    quantity: 0,
                    totalAmount: 0,
                    totalAmount: 0,
                    price: t.sellingPriceAtTime || 0,
                    dates: [],
                    receiverNames: new Set()
                };
            }
            productMap[t.productName].quantity += t.quantity;
            productMap[t.productName].totalAmount += (t.quantity * (t.sellingPriceAtTime || 0));
            productMap[t.productName].dates.push(new Date(t.date));
            if (t.receiverName) productMap[t.productName].receiverNames.add(t.receiverName);
        });

        const tableBody = Object.values(productMap).map(item => {
            const minDate = new Date(Math.min(...item.dates)).getDate();
            const maxDate = new Date(Math.max(...item.dates)).getDate();
            const dateRange = minDate === maxDate ? `${minDate}` : `${minDate}-${maxDate}`;
            const receiverNamesStr = item.receiverNames && item.receiverNames.size > 0
                ? Array.from(item.receiverNames).join(', ')
                : '-';

            // For NVS SAMA SAMA, use Receiver Name in the last column. For others, use Date Range.
            const lastColumnValue = platform === 'NVS SAMA SAMA' ? receiverNamesStr : dateRange;

            return [
                item.productName,
                item.quantity,
                `RM ${item.price.toFixed(2)}`,
                `RM ${item.totalAmount.toFixed(2)}`,
                lastColumnValue
            ];
        }).sort((a, b) => a[0].localeCompare(b[0]));

        const tableHeaders = platform === 'NVS SAMA SAMA'
            ? [['Product Name', 'Qty Sold', 'Price', 'Total Amount', 'Receiver Name']]
            : [['Product Name', 'Qty Sold', 'Price', 'Total Amount', 'Date Range']];

        autoTable(doc, {
            startY: y,
            head: tableHeaders,
            body: tableBody,
            theme: 'grid',
            headStyles: { fillColor: PRIMARY_COLOR, textColor: [255, 255, 255] },
            styles: { fontSize: 9, cellPadding: 3 },
            columnStyles: {
                3: { halign: 'right' },
                4: { halign: 'center' }
            }
        });

        y = doc.lastAutoTable.finalY + 10;
    });

    // 3. Stock-In Breakdown
    // Check page break
    if (y > 220) { doc.addPage(); y = 20; }
    y = addSectionTitle(doc, "3. Stock-In Breakdown", y);

    const stockInOnly = data.stockIn.filter(t => t.type === 'IN');
    const stockInBody = stockInOnly.map(t => [
        t.productName,
        t.quantity,
        t.supplier || '-',
        t.date
    ]);

    autoTable(doc, {
        startY: y,
        head: [['Product Name', 'Stock-In Qty', 'Supplier', 'Date']],
        body: stockInBody,
        theme: 'grid',
        headStyles: { fillColor: PRIMARY_COLOR, textColor: [255, 255, 255] },
        styles: { fontSize: 9, cellPadding: 3 }
    });

    y = doc.lastAutoTable.finalY + 10;

    // 4. Return Breakdown
    if (y > 220) { doc.addPage(); y = 20; }
    y = addSectionTitle(doc, "4. Return Breakdown", y);

    const returnsOnly = data.stockIn.filter(t => t.type === 'RETURN');
    const returnBody = returnsOnly.map(t => [
        t.productName,
        t.quantity,
        t.platform || '-',
        t.returnReason || '-',
        t.notes || '-'
    ]);

    autoTable(doc, {
        startY: y,
        head: [['Product Name', 'Return Qty', 'Platform', 'Return Reason', 'Notes']],
        body: returnBody,
        theme: 'grid',
        headStyles: { fillColor: PRIMARY_COLOR, textColor: [255, 255, 255] },
        styles: { fontSize: 9, cellPadding: 3 }
    });

    y = doc.lastAutoTable.finalY + 10;

    // 5. Platform Performance Overview
    if (y > 200) { doc.addPage(); y = 20; }
    y = addSectionTitle(doc, "5. Platform Performance Overview", y);

    if (data.platformPerformance) {
        const platformBody = data.platformPerformance.map(p => [
            p.platform,
            p.sales,
            `${p.percentage.toFixed(1)}%`,
            p.returns,
            p.net
        ]);

        autoTable(doc, {
            startY: y,
            head: [['Platform', 'Total Sales', '% Contribution', 'Total Returns', 'Net Performance']],
            body: platformBody,
            theme: 'grid',
            headStyles: { fillColor: SECONDARY_COLOR, textColor: [255, 255, 255] },
            styles: { fontSize: 9, cellPadding: 3 },
            columnStyles: {
                2: { halign: 'center' },
                4: { halign: 'right', fontStyle: 'bold' }
            }
        });
        y = doc.lastAutoTable.finalY + 10;
    }

    // 6. Auto Insights
    if (y > 200) { doc.addPage(); y = 20; }
    y = addSectionTitle(doc, "6. Auto Insights", y);

    const insights = data.monthlyInsights || {};
    const notesData = [
        [`Best-selling product: ${insights.bestSellingProduct || '-'}`],
        [`Week with highest sales: ${insights.highestSalesWeek || '-'}`],
        [`Platform with highest growth: ${insights.highestGrowthPlatform || '-'}`],
        [`Products with unusual returns: ${insights.unusualReturns || '-'}`],
        [`Recommendations: ${insights.recommendations || '-'}`]
    ];

    autoTable(doc, {
        startY: y,
        body: notesData,
        theme: 'plain',
        styles: { fontSize: 10, cellPadding: 2 },
        columnStyles: { 0: { fontStyle: 'italic' } }
    });

    // 7. Closing Stock Report (Next Month Opening)
    if (y > 200) { doc.addPage(); y = 20; }
    y = addSectionTitle(doc, "7. Closing Stock Report (Next Month Opening)", y);

    if (data.closingStock && data.closingStock.length > 0) {
        const closingStockBody = data.closingStock.map(p => [
            p.name,
            p.category,
            `${p.closingStock} units`
        ]).sort((a, b) => a[0].localeCompare(b[0]));

        autoTable(doc, {
            startY: y,
            head: [['Product Name', 'Category', 'Closing Stock (Next Month Opening)']],
            body: closingStockBody,
            theme: 'grid',
            headStyles: { fillColor: SECONDARY_COLOR, textColor: [255, 255, 255] },
            styles: { fontSize: 9, cellPadding: 3 },
            columnStyles: {
                2: { halign: 'right', fontStyle: 'bold' }
            }
        });
    } else {
        doc.setFontSize(10);
        doc.setTextColor(...TEXT_COLOR);
        doc.setFont('helvetica', 'italic');
        doc.text("No closing stock data available.", MARGIN, y + 5);
    }

    addFooter(doc);
    doc.save(`Monthly_Report_${month}.pdf`);
};

export const generateProductReportPDF = (data, product, platformFilter = 'All Platforms') => {
    const doc = new jsPDF();
    let y = addHeader(doc, "Product Performance Report", new Date().toLocaleDateString());

    doc.setFontSize(12);
    doc.setTextColor(...TEXT_COLOR);
    doc.text(`Product: ${product.name}`, MARGIN, y);
    doc.setFontSize(10);
    doc.text(`Category: ${product.category} | Price: RM ${product.sellingPrice}`, MARGIN, y + 6);

    if (platformFilter !== 'All Platforms') {
        doc.text(`Platform: ${platformFilter}`, PAGE_WIDTH - MARGIN, y, { align: 'right' });
    }
    y += 15;

    // Helper for aggregation by platform
    const aggregateByPlatform = (transactions) => {
        const map = {};
        transactions.forEach(t => {
            const platform = t.platform || '-';
            if (!map[platform]) {
                map[platform] = {
                    platform: platform,
                    quantity: 0
                };
            }
            map[platform].quantity += t.quantity;
        });
        return Object.values(map).sort((a, b) => a.platform.localeCompare(b.platform));
    };

    // --- Table 1: Total Sales (Stock Out) ---
    doc.setFontSize(12);
    doc.setTextColor(33, 150, 243); // Blue
    doc.text("Total Sales", MARGIN, y);
    y += 5;

    const salesData = aggregateByPlatform(data.stockOut);

    autoTable(doc, {
        startY: y,
        head: [['Platform', 'Total Sales']],
        body: salesData.map(item => [
            item.platform,
            item.quantity
        ]),
        theme: 'grid',
        styles: { fontSize: 10, cellPadding: 5, lineColor: [200, 200, 200], lineWidth: 0.1 },
        headStyles: { fillColor: [33, 150, 243], textColor: [255, 255, 255], fontStyle: 'bold' }, // Blue
        columnStyles: {
            0: { cellWidth: 100 },
            1: { cellWidth: 50, halign: 'center' }
        }
    });

    y = doc.lastAutoTable.finalY + 15;

    // --- Table 2: Total Stock In ---
    doc.setTextColor(76, 175, 80); // Green
    doc.text("Total Stock In", MARGIN, y);
    y += 5;

    const stockInData = aggregateByPlatform(data.stockIn.filter(t => t.type === 'IN'));

    autoTable(doc, {
        startY: y,
        head: [['Platform', 'Total Stock In']],
        body: stockInData.map(item => [
            item.platform,
            item.quantity
        ]),
        theme: 'grid',
        styles: { fontSize: 10, cellPadding: 5, lineColor: [200, 200, 200], lineWidth: 0.1 },
        headStyles: { fillColor: [76, 175, 80], textColor: [255, 255, 255], fontStyle: 'bold' }, // Green
        columnStyles: {
            0: { cellWidth: 100 },
            1: { cellWidth: 50, halign: 'center' }
        }
    });

    y = doc.lastAutoTable.finalY + 15;

    // --- Table 3: Total Return ---
    doc.setTextColor(244, 67, 54); // Red
    doc.text("Total Return", MARGIN, y);
    y += 5;

    const returnData = aggregateByPlatform(data.stockIn.filter(t => t.type === 'RETURN'));

    autoTable(doc, {
        startY: y,
        head: [['Platform', 'Total Return']],
        body: returnData.map(item => [
            item.platform,
            item.quantity
        ]),
        theme: 'grid',
        styles: { fontSize: 10, cellPadding: 5, lineColor: [200, 200, 200], lineWidth: 0.1 },
        headStyles: { fillColor: [244, 67, 54], textColor: [255, 255, 255], fontStyle: 'bold' }, // Red
        columnStyles: {
            0: { cellWidth: 100 },
            1: { cellWidth: 50, halign: 'center' }
        }
    });

    addFooter(doc);
    doc.save(`Product_Report_${product.name.replace(/\s+/g, '_')}.pdf`);
};
